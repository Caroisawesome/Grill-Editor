<html>
  <head>
    <title>SeismogramTest</title>
    <script src="../lib/agentscript.js"></script>
    <script src="../lib/mouse.js"></script>
    <script src="../tools/dat.gui.min.js"></script>
    <script src="../lib/as.dat.gui.js"></script>
    <script src="../tools/coffee-script.js"></script>
    <script type="text/javascript">
        myModel = function () {
            var u = ABM.Util
            ABM.Model.prototype.startup = function () {
                console.log("startup");
            };
            ABM.Model.prototype.setup = function() {
                this.patches.usePixels();
                this.refreshPatches = false;
                this.refreshLinks = true;

                // defaults
                this.agentBreeds("nodes");
                this.nodes.setDefault("shape", "circle");
                this.nodes.setDefault("size", 3);

                this.anim.setRate(30, true );

                // globals
                this.numNodes = 10;
                this.x1 = this.patches.maxX/5;
                this.x2 = this.patches.maxX * (4/5);
                this.y = this.patches.maxY/8;
                this.previousNode = null;
                this.meanLines = [];
                this.nodeDict = {};

                // toggleable constraints
                this.averageMeanLine = false;
                this.sameSlope = false;
                this.connectEndPoint = false;

                this.links.setDefault("layoutColor", [255,0,255]);

                this.mouse = new ABM.Mouse(this);
                this.setupNodesAndLinks();
                this.setupPatches();
                this.setupMouseEvents();
                


            }


            ABM.Model.prototype.step = function() {

            }

            ABM.Model.prototype.setupNodesAndLinks = function(){
                    this.nodes.create(this.numNodes);
                    for (var i = 0; i < this.agents.length; i++) {
                        node = this.agents[i];
                        this.nodeDict[node.id] = node;
                        i % 2 === 0 ? x = this.x1 : x = this.x2;
                        if (i % 2 === 0) {this.y += this.patches.maxY/10};
                        node.setXY(x, this.y)
                        if (this.previousNode !== null && i % 2 !== 0) {
                            var link = this.links.create(node, this.previousNode);
                            this.meanLines.push(link[0]);
                        }
                        this.previousNode = node; 
                    }
                
            }

            ABM.Model.prototype.setupPatches = function() {
                for (p of this.patches) {
                    p.color = [0,0,0, 0.2];
                }
            }

            ABM.Model.prototype.setupMouseEvents = function() {
                this.nodes.setDraggable();
                this.links.setDraggable();
                this.links.on("drag", this.checkLinkConstraints.bind(this))
                this.nodes.on("drag", this.checkAgentConstraints.bind(this))
            }

            ABM.Model.prototype.checkLinkConstraints = function(e) {
                if (this.averageMeanLine) { this.averageMeanLines(e.target) }
            }

            ABM.Model.prototype.checkAgentConstraints = function(e) {
                if (this.sameSlope) { this.adjustSlopeOfLines(e.target) }
                if (this.connectEndPoint) { this.adjustCorrespondingEndPoint(e.target, e.dy) }
            }

            ABM.Model.prototype.adjustCorrespondingEndPoint = function(node, dy) {
                var id, linkNeighbor = node.linkNeighbors()[0];
                node.id < linkNeighbor.id ? id = node.id + 2 : id = node.id - 3 ; 
                var newLineNeighbor = this.nodeDict[id];

                if (newLineNeighbor) {
                    newLineNeighbor.setXY(newLineNeighbor.p.x, newLineNeighbor.p.y - dy);
                }


            }

            ABM.Model.prototype.adjustSlopeOfLines = function(node) {
                var neighbor = node.linkNeighbors()[0];
                var slope = (node.p.y - neighbor.p.y)/(node.p.x - neighbor.p.x);

                for (link of this.meanLines) {
                    if (neighbor.id > node.id) {
                        var yIntercept = link.end1.p.y - (slope * link.end1.p.x);
                        var end2y = (slope * link.end2.p.x) + yIntercept; 
                        link.end2.setXY(link.end2.p.x, end2y);
                    } else {
                        var yIntercept = link.end2.p.y - (slope * link.end2.p.x);
                        var end1y = (slope * link.end1.p.x) + yIntercept; 
                        link.end1.setXY(link.end1.p.x, end1y);
                    }

                }

            }

            ABM.Model.prototype.averageMeanLines = function(link) {
                var bottomLink = this.meanLines[0];
                var topLink = this.meanLines[this.meanLines.length-1];
                var baseLink;   // remains stationary when other links are dragged.
                                // baseLink is bottom link unless bottom link is dragged
                                // else, top link.

                bottomLink == link ? baseLink = topLink : baseLink = bottomLink;

                var numMidLinks = Math.abs(link.id - baseLink.id);
                var distLinkToBaseLinkEnd1Y = Math.abs(link.end1.p.y - baseLink.end1.p.y);
                var distLinkToBaseLinkEnd2Y = Math.abs(link.end2.p.y - baseLink.end2.p.y);
                var distanceBtwnLinksEnds1Y = distLinkToBaseLinkEnd1Y/numMidLinks;
                var distanceBtwnLinksEnds2Y = distLinkToBaseLinkEnd2Y/numMidLinks;

                for (link of this.meanLines) {
                    var Y1 = this.meanLines[0].end1.p.y + (distanceBtwnLinksEnds1Y * link.id);
                    var Y2 = this.meanLines[0].end2.p.y + (distanceBtwnLinksEnds2Y * link.id);

                    link.end1.setXY(link.end1.p.x, Y1 );
                    link.end2.setXY(link.end2.p.x, Y2 );

                }

            }

            model = new ABM.Model({
                div: "layers",
                size: 2,  
                minX: 1,
                maxX: Math.floor(window.innerWidth/2),
                minY: 1,
                maxY: Math.floor(window.innerHeight/2)
            });

            model.debug();
            model.start();

            gui = new ABM.DatGUI(model, {
              "sameSlope": {
                type: "switch",
                val: false
              },
              "connectEndPoint": {
                type: "switch",
                val: false
              },
              "averageMeanLine": {
                type: "switch",
                val: false
              }
            })

        }
    </script>
  </head>

  <body onload="myModel();">
    <div id="layers"></div>
  </body>
</html>